pc寄存器：
	严格来说是一个数据结构，它用于保存当前正常执行的程序的内存地址。同时，java程序是多线程执行的，所以不可能一直都按线性执行下去，当有多个线程交叉执行时，
	被中断线程的程序当前执行到哪条的内存地址必然要保存下来，以便于他被恢复执行时再按照被中断时的指令地址继续执行下去。

java栈：
	栈总是和线程关联在一起，每当创建一个线程时，jvm就会为这个线程创建一个对应的java栈，在这个栈中又会含有多个栈帧，这些栈帧是与每个方法关联起来的，每运
	行一个方法就创建一个栈帧，每个栈帧会含有一些内部变量（在方法内定义的变量）、操作栈和方法返回值等信息。
	每当一个方法执行完成时，这个栈帧就会弹出栈帧的元素作为这个方法的返回值，并清除这个栈帧，java栈的栈顶的栈帧就是当前正在执行的方法，pc寄存器也会指向这
	个地址。只有这个活动的栈帧的本地变量可以被操作栈使用，当在这个栈帧中调用另一个方法时，与之对应的一个新的栈帧又被创建，这个新创建的栈帧又被放到栈顶，变
	为当前活动栈帧。同样现在只有这个栈帧的本地变量才能被使用，当在这个栈帧中所有指令执行完毕后这个栈帧移出java栈，刚才的那个栈帧又变为活动栈帧，前面的栈
	帧的返回值又变为这个栈帧的操作栈中的一个操作数，如果前面的栈帧没有返回值，那么当前的栈帧的操作栈的操作数没有变化。
	有java栈是与java线程对应起来的，这个数据不是线程共享的，所以我们不用关心它的数据一致性问题，也不会存在同步锁的问题。

堆：
	存储java对象的地方，每一个存储在堆中的java对象都会是这个对象的类的一个副本，它会复制包括继承自它父类的所有非静态属性。
	堆是被所有java线程所共享的，所以对他的访问需要注意同步问题。

方法区：
	jvm方法区是用于存储类结构信息的地方，一个class文件的常量池、域、方法数据、方法体、构造函数，包括类中的专用方法、实例初始化、接口初始化都存储在这个区
	域。
	方法区也属于java堆中的一部分，也就是我们通常所说的java堆中的永久区。这个区域可以被所有的线程共享，并且它的大小可以通过参数设置。

运行时常量池：
	包括编译期的数字常量、方法或者域的引用（在运行时解析）。这个常量池与前面方法区的常量池是一回事，它是方法区的一部分，所以他的存储也受方法区的规范约束，
	如果常量池无法分配，同样会抛出OutOfMemoryError。